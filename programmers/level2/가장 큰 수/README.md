**문제설명**

0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.

예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.

0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.

**제한사항**
- numbers의 길이는 1 이상 100,000 이하입니다.
- numbers의 원소는 0 이상 1,000 이하입니다.
- 정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.

**입출력 예**<br/>
|numbers|return|
|-|-|
|[6, 10, 2]|"6210"|
|[3, 30, 34, 5, 9]|"9534330"|
<br/>

**입출력 예 설명**

**입출력 예 #1**

첫 번째 라운드에서 4번 참가자는 3번 참가자와 붙게 되고, 7번 참가자는 8번 참가자와 붙게 됩니다. 항상 이긴다고 가정했으므로 4번 참가자는 다음 라운드에서 2번이 되고, 7번 참가자는 4번이 됩니다. 두 번째 라운드에서 2번은 1번과 붙게 되고, 4번은 3번과 붙게 됩니다. 항상 이긴다고 가정했으므로 2번은 다음 라운드에서 1번이 되고, 4번은 2번이 됩니다. 세 번째 라운드에서 1번과 2번으로 두 참가자가 붙게 되므로 3을 return 하면 됩니다.
<br/>
<hr/>
<br/>

**문제풀이**<br/>

처음 이 문제를 보고 든 생각은 단순히 `numbers`에 나오는 모든 순열을 구한 후 최댓값을 구하는 된다고 생각했지만, 그 방법은 비효율적이라는 것을 직감하고 다른 방법을 생각했습니다.

생각한 다른 방법은 `numbers`를 일정한 함수를 통해 정렬 후 이를 합치는 것이다. 생각한 함수는 아래와 같습니다.

1. 비교할 `numbers`의 두 원소 `a`, `b`를 가져옵니다.
2. 두 원소의 순열을 구합니다.
   
   `ab`, `ba`
3. 두 개의 순열 중 큰 것이 앞으로 가도록 정렬합니다. 내림차순으로 정렬되려먼 뒤에 있는 것이 큰도록 하면 됩니다.
   
   `ba` - `ab`

정렬을 마친 후엔 `numbers`를 `join('')`하여 문자열로 만들고, 입력값이 `[0, 0, 0, 0]`인 경우가 있을 수 있으므로 `join`한 `numbers`의 0번째 원소가 0이면 `'0'`을 그렇지 않으면 `join`한 `numbers`를 반환합니다.
   
