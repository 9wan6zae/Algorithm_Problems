**출처**

[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/1844)

**풀이**

BFS를 이용해 문제를 해결하였습니다. BFS를 이용해 문제를 푼 이유는 미로 같이 후보를 이용해 최단거리를 구하는 경우에 한 곳으로 계속 보는 것보단 앞선 선택지의 다양한 경우를 보는 곳이 더 낫기 때문입니다.

문제는 아래와 같은 과정으로 해결하였습니다.

1. `queue`에 최초 위치인 [0, 0]를 넣습니다.
2. 방문횟수를 의미하는 `visitCount`를 `maps`의 크기만큼 생성하고 모두 0으로 채웁니다.
3. 최초 위치인 `visitCount[0][0]`에는 1로 초기화합니다.
4. `queue.length`가 0이 아닐 때까지 반복합니다.
   1. `queue`의 첫 원소를 `[y, x]`라고 합니다.
   2. 현재 시점에서 갈 수 있는 4개의 방향을 각각 갑니다.
      1. 이동 변이를 `dy`, `dx`라 하고, 각 이동힐 좌표를 `[next_y, next_x]`라 할 때 이는 `[y+dy, x_dx]`가 됩니다.
      2. 이동할 좌표가 맵의 안에 있고, `maps`에 대응되는 좌표의 값이 `1`이고 `visitCount`에 대응되는 좌표의 값이 `0`일 때, `visitCount[next_y][next_x]`를 `visitCount[y][x] + 1`한 값으로 초기화하고 `queue`에 `[next_y, next_x]`를 `push`합니다.
5. 위 과정을 거치고 최종 종료 지점에 대응되는 좌표인 `[row - 1][col - 1]`의 `visitCount` 값이 0이면 도달하지 않았다는 말이므로 `-1`을 반환하고 그렇지 않다면 해당 값을 반환합니다.