**문제설명**<br/>
다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.<br/>
* `()`, `[]`, `{}` 는 모두 올바른 괄호 문자열입니다.
* 만약 `A`가 올바른 괄호 문자열이라면, `(A)`, `[A]`, `{A}` 도 올바른 괄호 문자열입니다. 예를 들어, `[]` 가 올바른 괄호 문자열이므로, `([])` 도 올바른 괄호 문자열입니다.
* 만약 `A`, `B`가 올바른 괄호 문자열이라면, `AB` 도 올바른 괄호 문자열입니다. 예를 들어, `{}` 와 `([])` 가 올바른 괄호 문자열이므로, `{}([])` 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 `s`가 매개변수로 주어집니다. 이 `s`를 왼쪽으로 x (0 ≤ x < (`s`의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.<br/>

**제한사항**
* s의 길이는 1 이상 1,000 이하입니다.
<br/>

**입출력 예**<br/>

|s|result|
|-|-|
|"[](){}"|3|
|"}]()[{"|2|
|"[)(]"|0|
|"}}}"|0|<br/>
<br/>

**입출력 예 설명**<br/>
입출력 예 #1<br/>
* 다음 표는 `"[](){}"` 를 회전시킨 모습을 나타낸 것입니다.<br/>
  |x|s를 왼쪽으로 x칸만큼 회전|올바른 괄호 문자열?|
  |-|-|-|
  |0|"[](){}"|O|
  |1|"](){}["|X|
  |2|"(){}[]"|O|
  |3|"){}[]("|X|
  |4|"{}[]()"|O|
  |5|"}[](){"|X|<br/>
* 올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.

입출력 예 #2<br/>
* 다음 표는 `"}]()[{"` 를 회전시킨 모습을 나타낸 것입니다.<br/>
  |x|s를 왼쪽으로 x칸만큼 회전|올바른 괄호 문자열?|
  |-|-|-|
  |0|"}]()[{"|X|
  |1|"]()[{}"|X|
  |2|"()[{}]"|O|
  |3|")[{}]("|X|
  |4|"[{}]\()"|O|
  |5|"{}]()["|X|<br/>
* 올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.<br/>
  
입출력 예 #3<br/>
* s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다<br/>
 
입출력 예 #4<br/>
* s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다<br/>
<br/>
<hr/>
<br/>

**문제풀이**<br/>
단순하게 생각했을 때 `s`의 길이만큼 이중 반복하면서, 첫 번째 반복문에선 `s`를 회전시키고 두 번째 반복문에션 `s`의 요소를 조건으로 비교해서 `stack`에 넣을지 또는 올바르지 않은 상황인지를 확인하면 문제가 풀릴 것이라고 확신했습니다.<br/>
<br/>
1. 괄호 회전하기<br/>
   문자열 `s`의 처음 요소를 뺀 후 마지막에 붙이는 과정을 통해 괄호를 회전합니다.
   ```
   s.push(s.shift());
   ```
2. `stack` 생성하기<br/>
   괄호들을 저장할 `stack`을 생성합니다.
   ```
   stack = [];
   ```
3. 조건으로 비교하기<br/>
   ```
   const bracket = s[j];
   ```
   1. 왼쪽 `bracket`일 때<br/>
      왼쪽 `bracket`일 때는 `stack`에 `push`합니다.
      ```
      if (is_left) stack.push(bracket);
      ```
   2. 오른쪽 `bracket`일 때<br/>
      1. `stack`의 비어 있을 때<br/>
          `stack`이 비어 있는 상태에서 오른쪽 괄호가 들어간다면 올바르지 않기 때문에 `invalid`를 `true`로 변경합니다.
          ```
          if (!stack.length) {
            invalid = true;
            break;
          }
          ```
      2. 그렇지 않을 때<br/>
          1. `stack`의 마지막 값과 `bracket`의 쌍이 맞을 때<br/>
              쌍이 맞는 경우에는 `stack`을 `pop`을 합니다.
              ```
              if (pair[last_val] === bracket) stack.pop();
              ```
          2. 그렇지 않을 때<br/>
              쌍이 맞지 않은 경우에는 올바르지 않기 때문에 `invalid`를 `true`로 변경합니다.
              ```
              else {
                invalid = true;
                break;
              }
              ```
4. `answer` 계산하기<br/>
   `invalid`가 `false`이고, 괄호의 쌍이 모두 맞아 `stack`에 아무 것도 없을 때 `answer`를 증가합니다.
   ```
   if (!invalid && !stack.length) answer += 1;
   ```