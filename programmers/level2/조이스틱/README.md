**문제설명**

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

```
▲ - 다음 알파벳
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)
▶ - 커서를 오른쪽으로 이동
```

예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.
```
- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.
```
만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

**제한사항**
- name은 알파벳 대문자로만 이루어져 있습니다.
- name의 길이는 1 이상 20 이하입니다.

**입출력 예**<br/>
|name|return|
|-|-|
|"JEROEN"|56|
|"JAN"|23|
<br/>
<hr/>
<br/>

**문제풀이**<br/>

이 문제를 풀기 위해선 두 가지를 계산해야 합니다. 하나는 알파벳에 따른 숫자 그리고 다른 하나는 움직이는 횟수입니다. 조이스틱은 상하로 움직이면 알파벳이 바뀌고 위로 움직이면 정방향, 아래로 움직이면 역방향입니다. 따라서, 알파벳에 따라 가까운 방향이 있기 때문에 이를 계산합니다.
간단하게 a에서 `name[i]`를 뺀 값을 `closer_a`, `name[i]`에서 z를 뺀 값을을 `closer_z`라고 했을 때, 이 두 개의 `min`값을 `answer`에 더하면 됩니다. 이 과정을 `name`의 모든 문자에 적용한 후에 움직이는 횟수를 카운팅합니다.

`name`에서 A가 있을 때 원래 방향으로 갈지 반대 방향으로 갈지를 정해야 합니다. 만약 `ZZAAAZ`같은 문자열이 `name`으로 주어졌을 때 오른쪽으로 진행하면 8이 됩니다. 하지만 두 번째 Z에서 반대로 가게 되면 6이 되어서 이 `name`의 정답은 6이 됩니다.
하지만, `name`으로 `ZZZZAAZ`가 주어지게 된 경우에는 위와 같이 역으로 가게 되면 12가 되고 정방향으로 가면 11이 됩니다. 연속되는 A의 위치에 따라 다른 결과가 나온다는 것을 알 수 있습니다.
A가 연속으로 시작되는 부분에서 우회할 지 그대로 진행할지 결정짓는 요소는 과연 우회했을 때가 더 좋은지입니다. 따라서, A가 연속되는 문자열의 개수에서 A가 시작되기 전의 인덱스를 뺀 값들을 모은 후 그 중에서 가장 큰 값을 `answer`에서 빼게 되면 정답을 구할 수 있게 됩니다.
