**출처**<hr>
level 3   
[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/12952)
<br>

**풀이**<hr>
백트래킹의 대표적인 문제인 `N-Queen` 문제입니다. 백트래킹은 `dfs` 또는 `bfs`를 이용해 문제을 풀 수 있습니다. 일단 가능한 모든 것을 시도하고 문제의 조건을 충족하지 못한다면 다른 시도를 하는 문제입니다. `n * n` 사이즈의 체스판에 `n`개의 퀸을 둘 수 있는 방법의 수를 반환하는 문제이기 때문에 처음엔 2차원 배열을 만들어 현재 행에 퀸이 놓인 열에 따라 둘 수 있는 곳을 체크하려고 했지만, 비효율적이라고 생각해 1차원 배열을 이용해 퀸의 위치를 표시하도록 했습니다. 예를 들어 [1, 2]라고 할 때, 퀸은 (0, 1)과 (1, 2)에 위치해 있습니다. 해당 행에 퀸이 놓이면 그 행에는 퀸을 둘 수 없기 때문에 이처럼 표현할 수 있습니다.

퀸은 가로, 세로 그리고 대각선으로 이동할 수 있기 때문에 퀸의 위치를 관리하는 배열에서 원소들이 같은 값을 가지거나, 각 값의 차와 행과의 차가 같으면 갈 수 없게 됩니다.

- [1, 1]인 경우, 2개의 퀸이 1열에 위치하고 있다는 말이므로 같은 열에 위치하고 있습니다. 따라서, 둘 수 없는 경우입니다.
- [1, 2]인 경우, 2개의 퀸이 (0, 1), (1, 2)에 위치하고 있으므로 대각선에 위치하고 있습니다. 즉, 둘 수 없는 경우에 해당하는데 두 개의 값의 차인 (2 - 1)와 행의 차인 (1 - 0)이 같으면 대각선에 위치하고 있다는 것을 알 수 있게 됩니다.

```js
board[i] === board[row] || Math.abs(i - row) === Math.abs(board[i] - board[row]
```

따라서, 위의 경우일 땐 둘 수 없다는 것을 알 수 있습니다. 퀸을 둘 때마다 위 조건을 확인하면서 둘 수 있는지를 확인합니다. 그리고 행의 수와 `n`이 같다면 모든 퀸을 둔 것이기 때문에 이 경우 1을 반환해 `dfs` 재귀를 멈춰 `count`를 증가합니다.

```js
const dfs = (board, row) => {
    let count = 0
    
    if (row === n) {
        return 1
    }
    
    for (let col = 0; col < n; col += 1) {
        board[row] = col
        
        if (check(board, row)) {
            count += dfs(board, row + 1)
        }
    }
    return count
}
```