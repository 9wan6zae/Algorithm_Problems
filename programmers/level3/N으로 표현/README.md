**출처**<hr>
level 3   
[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/42895)
<br>

**풀이**<hr>

`N`이 5라고 할 때,   
`5` 하나로 표현할 수 있는 것은   
`5` 뿐입니다.

`5` 두 개로 표현할 수 있는 것은   
- `55`
- `5 + 5 = 10`
- `5 * 5 = 25`
- `5 - 5 = 0`
- `5 / 5 = 1`
  
입니다.

`5` 세 개로 표현할 수 있는 것은 이전에 구한 하나로 표현 가능한 것과 두 개로 표현 가능한 것의 조합일 것입니다. 뒤에 있는 것도 마찬가지로 표현이 가능합니다. 이때, 중복이 발생할 수 있으므로 각 개수로 표현이 가능한 것을 `Set`을 이용해 저장하고 원하는 `number`가 있는지 확인해 해당되는 개수를 반환하면 됩니다.

최솟값이 8보다 크면 -1을 반환하므로, `N`이 8번 반복되는 경우가 최대를 의미합니다. 따라서, 편의를 위해 `9`의 크기만큼 할당하고 `Set`으로 초기화합니다.

``` js
const dp = Array.from(new Array(9), () => new Set())
```

만약, `N`이 `number`라면 1이므로 1을 반환합니다.

``` js
if (N === number) return 1
```

1부터 반복해 `iterator`가 9가 되기 전까지 반복합니다. `dp[i]`에 `i`만큼 `N`을 반복해서 넣어줍니다. 이렇게 하는 이유는 아무 연산을 하지 않고 특정 개수의 `N`이 있는 경우는 `N`이 그 개수만큼 있는 것이기 때문입니다.

`dp[1] = [5]`   
`dp[2] = [55]`   
`...`

`dp[i]`에는 `dp[i-j]`와 `dp[j]`의 조합으로 구성됩니다. 이때, `j`는 `i`를 넘을 수 없습니다. 즉, 아래의 코드처럼 계산됩니다.

``` js
for (let j = 1; j < i; j += 1) {
    for (const arg1 of dp[j]) {
        for (const arg2 of dp[i - j]) {
            dp[i].add(arg1 + arg2)
            dp[i].add(arg1 - arg2)
            dp[i].add(arg1 * arg2)
            dp[i].add(arg1 / arg2)
        }
    }
}
```

위의 로직을 마친 후 `dp[i]`에 찾고자 하는 `number`가 있는지 확인하고 있다면 `i`를 반환합니다.

``` js
if (dp[i].has(number)) return i
```

모든 반복문을 돌았음에도 구하는 값이 없다면 `-1`을 반환합니다.