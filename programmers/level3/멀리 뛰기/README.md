**출처**<hr>
level 3   
[프로그래머스](https://programmers.co.kr/learn/courses/30/lessons/12914)
<br>

**풀이**<hr>

| n | 개수 | 경우의 수 |
|-|-|-|
| 1 | 1 | [1]|
| 2 | 2 | [1, 1], [2]|
| 3 | 3 | [1, 1, 1], [1, 2], [2, 1]|
| 4 | 5 | [1, 1, 1, 1], [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2]|
| 5 | 8 | [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 1, 2, 1], [1, 2, 1, 1], [1, 2, 2], [2, 1, 1, 1], [2, 1, 2], [2, 2, 1]|
| 6 | 13 | [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 2], [1, 1, 1, 2, 1], [1, 1, 2, 1, 1], [1, 1, 2, 2], [1, 2, 1, 1, 1], [1, 2, 1, 2], [1, 2, 2, 1], [2, 1, 1, 1, 1], [2, 2, 1, 1], [2, 1, 2, 1], [2, 1, 1, 2], [2, 2, 2]|

`n`에 따른 개수는 위와 같습니다. 이는 점화식을 나타내면 피보나치 수열과 같게 됩니다.

dp[n] = dp[n-1] + dp[n-2] (n이 2보다 클 때)

따라서, dp 배열을 피보나치 수열로 `n`만큼 초기화해서 `dp[n]`을 반환하면 문제를 해결할 수 있습니다.