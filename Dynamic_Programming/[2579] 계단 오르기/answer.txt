계단의 개수만큼 dp를 할당한다.

dp의 각 인덱스에는 해당 계단일 때의 최댓값을 저장하고 있다.

계단은 하나 또는 두개까지 한번에 오를 수 있고, 연속으로 3개를 오를 수 없는 것이 조건으로 있다. 그리고 마지막 계단은 무조건 밟아야 하므로 마지막 인덱스의 값을 반환하면 된다.

input = [10, 20, 15, 25, 10, 20]이라고 했을 때
dp[0] => 첫 번째 계단의 값 -> input[0] = 10
dp[1] => 바로 두 번째 계단을 오르는 것과 첫 번째 계단을 밝고 가는 것 중 최댓값을 구함 -> Math.max(input[1], input[0] + input[1]) = 30
dp[2] => 첫 번째 계단을 밟고 간 것과 두 번째 계단을 밟고 간 것 중 최댓값을 구함 = Math.max(input[0] + input[2], input[1] + input[2]) = 35

dp[3]부터는 점화식을 사용
dp[n] = Math.max(자신의 발판 + 자기 앞 두 번째에 있는 발판에서의 최댓값, 자신의 발판 + 자신 바로 앞 발판 + 자기 앞 세 번째에 있는 발판에서의 최댓값)을 구한다.
그렇게 하는 이유는 자신에게 올 수 있는 경우가 위의 2가지가 있기 때문이다.
따라서, 식은
dp[n] = Math.max(input[i] + dp[i-2], input[i] + input[i-1] + dp[i-3])이 된다.

input[i] + dp[i-2]가 되지 않는 이유는 dp[i-2]에서 자기 바로 앞의 발판을 밟는 경우가 생길 수 있어 이는 연속으로 3개의 발판을 밟으면 안되는 규칙에 위배될 수 있다.